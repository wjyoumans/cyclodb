\r abelianbnf.gp

\\ len = 159
conductors0 = [97, 194, 101, 250, 202, 103, 206, 107, 214, 109, 218, 121, 242, 113, 226, 127, 254, 131, 262, 137, 274, 139, 278, 149, 298, 151, 302, 169, 157, 338, 314, 243, 163, 486, 326, 167, 334, 173, 346, 179, 358, 181, 362, 191, 382, 193, 386, 197, 394, 199, 398, 211, 422, 223, 446, 227, 454, 229, 458, 233, 466, 239, 478, 241, 482, 251, 502, 257, 514, 263, 526, 269, 538, 271, 542, 289, 578, 277, 554, 281, 562, 283, 566, 293, 586, 343, 686, 307, 614, 311, 622, 313, 626, 317, 634, 331, 662, 337, 674, 361, 722, 347, 694, 349, 698, 353, 706, 359, 718, 367, 734, 373, 746, 379, 758, 383, 766, 389, 778, 397, 794, 401, 802, 409, 818, 419, 838, 421, 842, 431, 862, 433, 866, 439, 878, 443, 886, 449, 898, 457, 914, 461, 922, 463, 926, 467, 934, 479, 958, 729, 487, 1458, 974, 491, 982, 499, 998, 625, 1250];

\\ len = 421
conductors1 = [155, 175, 310, 350, 201, 207, 402, 414, 284, 213, 426, 292, 219, 438, 444, 316, 237, 474, 332, 249, 498, 344, 261, 245, 215, 203, 522, 490, 430, 406, 516, 356, 368, 297, 209, 594, 418, 376, 235, 470, 564, 388, 448, 291, 582, 612, 476, 500, 404, 375, 303, 750, 606, 412, 309, 618, 424, 265, 636, 428, 321, 642, 436, 648, 327, 405, 654, 810, 484, 363, 253, 726, 506, 452, 339, 678, 472, 295, 590, 708, 488, 496, 369, 305, 325, 287, 738, 610, 650, 574, 732, 900, 572, 620, 700, 616, 429, 465, 525, 495, 385, 858, 930, 1050, 990, 770, 924, 508, 381, 762, 512, 768, 524, 393, 786, 536, 335, 299, 670, 598, 804, 828, 644, 483, 966, 548, 411, 822, 556, 417, 423, 329, 834, 846, 658, 568, 319, 355, 638, 710, 852, 584, 864, 608, 459, 365, 323, 918, 730, 646, 876, 740, 888, 1080, 760, 912, 555, 1110, 1140, 596, 447, 894, 604, 453, 906, 676, 628, 632, 507, 471, 477, 395, 371, 1014, 942, 954, 790, 742, 948, 656, 800, 704, 425, 850, 748, 820, 984, 1200, 880, 1056, 561, 615, 1122, 1230, 1320, 972, 652, 489, 978, 664, 415, 830, 996, 668, 501, 1002, 784, 688, 377, 754, 1044, 980, 860, 812, 1176, 1032, 735, 645, 609, 1470, 1290, 1218, 692, 519, 1038, 531, 413, 1062, 826, 712, 736, 445, 391, 890, 782, 1068, 920, 1104, 1380, 716, 537, 1074, 724, 543, 675, 407, 475, 1086, 1350, 814, 950, 1188, 836, 627, 1254, 752, 940, 1128, 705, 1410, 764, 573, 1146, 772, 776, 832, 1152, 896, 579, 485, 1158, 970, 1164, 884, 1224, 952, 1040, 1248, 1440, 1120, 1344, 663, 765, 595, 1326, 1530, 1190, 1428, 1560, 1680, 788, 591, 1182, 796, 597, 621, 437, 1194, 1242, 874, 1000, 808, 505, 1010, 1500, 1212, 824, 515, 1030, 1236, 848, 1060, 1272, 795, 1590, 844, 633, 639, 473, 497, 539, 1266, 1278, 946, 994, 1078, 856, 535, 1070, 1284, 872, 1296, 545, 1090, 1308, 1620, 968, 605, 575, 1210, 1150, 1452, 1012, 759, 1518, 892, 669, 1338, 904, 928, 565, 493, 1130, 986, 1356, 1160, 1392, 1740, 908, 681, 1362, 916, 687, 1374, 517, 1034, 932, 944, 699, 1398, 1180, 1416, 885, 1770, 956, 717, 1434, 964, 976, 992, 723, 527, 533, 1446, 1054, 1066, 1476, 1220, 1300, 1148, 1464, 1800, 1144, 1240, 1400, 1488, 1584, 1232, 915, 975, 861, 715, 1830, 1950, 1722, 1430, 1716, 1860, 2100, 1980, 1540, 1848, 1155, 2310, 747, 581, 1494, 1162, 1004, 753, 1506];

\\ len = 172
conductors2 = [637, 559, 1274, 1118, 1764, 1548, 1204, 903, 1806, 837, 589, 1674, 1178, 873, 679, 1746, 1358, 1872, 1456, 2016, 1071, 2142, 2340, 1820, 2184, 2520, 1365, 2730, 671, 775, 1342, 1550, 1364, 1023, 2046, 927, 721, 1854, 1442, 981, 999, 1053, 763, 703, 1962, 1998, 2106, 1526, 1406, 2052, 2268, 1197, 2394, 781, 1562, 793, 1586, 2196, 1708, 1612, 2232, 1736, 1281, 1209, 1287, 1395, 1575, 1085, 1001, 2562, 2418, 2574, 2790, 3150, 2170, 2002, 2604, 2772, 1143, 1323, 1161, 889, 931, 817, 2286, 2646, 2322, 1778, 1862, 1634, 871, 1742, 2412, 1876, 1407, 1449, 2814, 2898, 1025, 2050, 1804, 2200, 1353, 2706, 3300, 1251, 973, 2502, 1946, 949, 1898, 2628, 2044, 1924, 2664, 2808, 2072, 1976, 2736, 3024, 2128, 1533, 1443, 1665, 1755, 1295, 1235, 3066, 2886, 3330, 3510, 2590, 2470, 3108, 2964, 3420, 3276, 3780, 2660, 3192, 1995, 3990, 1359, 1057, 2718, 2114, 1521, 1413, 1183, 1099, 1027, 3042, 2826, 2366, 2198, 2054, 2844, 2212, 1659, 3318, 1467, 1539, 1701, 1141, 2934, 3078, 3402, 2282, 1111, 1375, 2222, 2750];

\\ abbnf[1] == 0: no norm relation
\\ abbnf[1] == 1: p-power relation
\\ abbnf[1] == 2: den 1 relation

getbrauer(abbnf) = {
  my(pol,abgal,cyc,cycnc,LsubCP,Lp,brauer);
  if(abbnf[1]==1,
    abbnf[23]
  ,abbnf[1]==2,
    pol = getpol(abbnf);
    abgal = abgaloisanalysis(pol);
    cyc = abgal_cyc(abgal);
    cycnc = vecprod(cyc[2..-1]);
    LsubCP = getsubfields_CP(abgal,'y,0,0);
    Lp = factor(poldegree(pol))[,1]~;
    brauer = LsubCP[,2]~;
    vector(#Lp,i,vector(#brauer,j,brauer[j][i]));
  );
}

\\ returns [type, [denominator, subfields]]
\\ where subfields = [type, [denominator, subfields]]
\\ and type = [0 (no norm relation), 1 (p-power), 2 (den 1)]
getnormreldata(abbnf) = {
  my(pol,abgal,cyc,cycnc,subfield_abbnfs,res);
  if(abbnf[1]==0,
    Vec(getpol(abbnf))
  ,abbnf[1]==1,
    pol = getpol(abbnf);
    abgal = abgaloisanalysis(pol);
    cyc = abgal_cyc(abgal);
    cycnc = vecprod(cyc[2..-1]);
    subfield_abbnfs = abbnf[5];
    res = vector(#subfield_abbnfs,i,
    	getnormreldata(subfield_abbnfs[i])
    );
    [Vec(pol),[cycnc,res]]
  ,abbnf[1]==2,
    subfield_abbnfs = abbnf[3];
    res = vector(#subfield_abbnfs,i,
    	getnormreldata(subfield_abbnfs[i])
    );
    [Vec(getpol(abbnf)),[1,res]]
  );
}

geth(abbnf) = {
  my(h,clgp);
  h = 1;
  clgp = getcyc(abbnf);
  for(i=1,#clgp,
    h *= clgp[i];
  );
  h;
}

getdisc(abbnf) =
{
  if(abbnf[1]==2, poldisc(getpol(abbnf));
  ,abbnf[1]==1, abbnf[18]
  ,/*else: 0*/ abbnf[2].disc
  );
};

getreg(abbnf, con) = 
{
  my(res,w,disc,r1,r2,h,Lbnf,bcoefs,brauer);
  if(abbnf[1]==0, 
    abbnf[2].reg
  ,abbnf[1]==1,
    res = getresidue(abbnf);
    w = abbnf[25];
    disc = getdisc(abbnf);
    [r1, r2] = abbnf[24];
    h = geth(abbnf);

    (res*w*sqrt(abs(disc)))/((2^r1)*((2*Pi)^r2)*h);
  ,abbnf[1]==2,
    nf = nfinit(getpol(abbnf));
    res = getresidue(abbnf);
    w = if(Mod(con,2)==0,con,2*con);
    disc = getdisc(abbnf);
    [r1, r2] = nf.sign;
    h = geth(abbnf);

    (res*w*sqrt(abs(disc)))/((2^r1)*((2*Pi)^r2)*h);
  );
}

\\ requires abbnf[1] == 1 aka p-power norm relation
getresidue(abbnf) =
{
  my(bcoefs,Lbnf,bnf,d,r1,r2,h,R,w,subres,res);
  if(abbnf[1] == 0,
    bnf = abbnf[2];
    [r1,r2] = bnf.sign;
    h = bnf.clgp.no;
    reg = bnf.reg;
    w = bnf.tu[1];
    d = bnf.nf.disc;

    res = (h*reg*(2^r1)*((2*Pi)^r2))/(w*sqrt(abs(d)));
    res;
  ,abbnf[1] == 1,
    bcoefs = getbrauer(abbnf);
    Lbnf = abbnf[5];

    res = 1;
    for(i=1,#Lbnf,
      subres = getresidue(Lbnf[i]);
      /*
      bnf = Lbnf[i][2];
      d = bnf.nf.disc;
      [r1, r2] = bnf.sign;
      h = bnf.clgp.no;
      R = bnf.reg;
      w = bnf.tu[1];

      subres = (h*R*(2^r1)*((2*Pi)^r2))/(w*sqrt(abs(d)));
      */
      res *= subres^bcoefs[i];
    );
    res;
  ,abbnf[1] == 2,
    bcoefs = getbrauer(abbnf);
    Lbnf = abbnf[3];
    res = 1;
    for(i=1,#Lbnf,
      res *= getresidue(Lbnf[i])^bcoefs[1][i];
    );
    res;
  );

};

totallyrealsubfield(f) = {
  z = Mod(x, f);
  minpoly(z + z^-1)
};

realsubfielddatatojson(conductor,abbnf,certified,t1,t2,{prec=100},{filename=""}) = {
  my(out_str,pol,nf,r1,r2,deg,disc,disc_bits,galgp,clgp,h,reg,res,normreldata,s,out);
  out_str="{ \"conductor\": %d, \"degree\": %d, \"polynomial\": %d, \"signature\": %d, \"norm_relation_type\": %d, \"discriminant\": %s, \"discriminant_bits\": %d, \"galois_group\": %d, \"class_group\": %d, \"h\": %s, \"regulator\": %s, \"residue\": %s, \"precision\": %d, \"certified\": %d, \"time_class_group\": %s, \"time_certify\": %s, \"norm_relation_data\": %s}";
  pol = getpol(abbnf);
  nf = easynf(pol);
  [r1,r2] = nf.sign;
  deg = poldegree(pol);
  disc = getdisc(abbnf);
  disc_bits = floor(log(abs(disc))/log(2));
  galgp = znstar(conductor)[2];
  clgp = getcyc(abbnf);
  h = geth(abbnf);
  reg = getreg(abbnf,conductor);
  res = getresidue(abbnf);
  normreldata = getnormreldata(abbnf);
  s = strprintf(
    out_str,
    conductor, 
    deg, 
    Vec(pol),
    [r1,r2], 
    abbnf[1], 
    strprintf("\"%d\"", disc), 
    disc_bits, 
    galgp, 
    clgp, 
    strprintf("\"%d\"", h), 
    strprintf("\"%f\"", reg), 
    strprintf("\"%f\"", res),
    prec,
    certified,
    t1,
    t2,
    normreldata
  );
  if(filename!="",
    out = concat(filename, "_real.out");
    system(strprintf("rm %s", out));
    write(out,s),
  );
  s
};

datatojson(conductor,abbnf,certified,t1,t2,{prec=100},{filename=""}) = {
  my(out_str,pol,nf,r1,r2,deg,disc,disc_bits,galgp,clgp,h,reg,hm,hp,res,normreldata,s,out);
  out_str="{ \"conductor\": %d, \"degree\": %d, \"polynomial\": %d, \"signature\": %d, \"norm_relation_type\": %d, \"discriminant\": %s, \"discriminant_bits\": %d, \"galois_group\": %d, \"class_group\": %d, \"h\": %s, \"h_minus\": %s, \"h_plus\": %s, \"regulator\": %s, \"residue\": %s, \"precision\": %d, \"certified\": %d, \"time_class_group\": %s, \"time_certify\": %s, \"norm_relation_data\": %s}";
  pol = getpol(abbnf);
  nf = easynf(pol);
  [r1,r2] = nf.sign;
  deg = poldegree(pol);
  disc = getdisc(abbnf);
  disc_bits = floor(log(abs(disc))/log(2));
  galgp = znstar(conductor)[2];
  clgp = getcyc(abbnf);
  h = geth(abbnf);
  reg = getreg(abbnf,conductor);
  hm = hminus(conductor);
  hp = h/hm;
  res = getresidue(abbnf);
  normreldata = getnormreldata(abbnf);
  s = strprintf(
    out_str,
    conductor, 
    deg, 
    Vec(pol),
    [r1,r2], 
    abbnf[1], 
    strprintf("\"%d\"", disc), 
    disc_bits, 
    galgp, 
    clgp, 
    strprintf("\"%d\"", h), 
    strprintf("\"%d\"", hm), 
    strprintf("\"%d\"", hp), 
    strprintf("\"%f\"", reg), 
    strprintf("\"%f\"", res),
    prec,
    certified,
    t1,
    t2,
    normreldata
  );
  if(filename!="",
    out = concat(filename, ".out");
    system(strprintf("rm %s", out));
    write(out,s),
  );
  s
};

\\ Note: tech = [0,0,4] default for bnf, [0.5,0.5,4] needed to finish subfields 
\\ of deg 1800 field in norm relation computations. May need to tweak this argument
cyclodata(conductor,{prec=100},{filename=""}) =
{
  my(f,g,abbnf,out,certified,t1,t2);

  f = polcyclo(conductor);
  printf("Computing abelianbnf of cyclotomic field with conductor %s.\n", conductor);
  t1 = getabstime();
  abbnf = abelianbnfinit(f);
  t1 = getabstime()-t1;
  print("Done: ", strtime(t1));
  out = datatojson(conductor, abbnf, certified, t1, t2, prec, filename);
  print(out);

  print("Certifying the result.");
  t2 = getabstime();
  certified = abelianbnfcertify(abbnf);
  t2 = getabstime()-t2;
  print("Done: ", strtime(t2));
  out = datatojson(conductor, abbnf, certified, t1, t2, prec, filename);
  print(out);
 
  \\ might help to clear memory of abbnf, not tested but cant hurt
  abbnf = 0;
  certified = 0;
  t1 = 0;
  t2 = 0;

  g = totallyrealsubfield(f);
  print("Computing abelianbnf of totally real subfield.");
  t1 = getabstime();
  abbnf = abelianbnfinit(g);
  t1 = getabstime()-t1;
  print("Done: ", strtime(t1));
  out = realsubfielddatatojson(conductor, abbnf, certified, t1, t2, prec, filename);
  print(out);

  print("Certifying the result.");
  t2 = getabstime();
  certified = abelianbnfcertify(abbnf);
  t2 = getabstime()-t2;
  print("Done: ", strtime(t2));
  out = realsubfielddatatojson(conductor, abbnf, certified, t1, t2, prec, filename);
  print(out);
};
